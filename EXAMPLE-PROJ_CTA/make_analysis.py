#!/usr/local/bin/python2.7
# vim: tw=0
#{{{ Import this, import that...
import os
import os.path
import bz2
import sys
import time
import array
import math
import glob
import re
import errno
import bvvPyMakeNoArgs
import subprocess
import itertools
import textwrap
import tempfile
import csv
import getpass
#}}}


# ==================================       SCRIPT PARAMETERS      ==========================================

# ENVIRONMENT VARIABLES used:
# ----------------------------
#
# OBS_EVNDISP_ANA_DIR
#       ED_PARAM_DIR directory with ED parameter files is basename $OBS_EVNDISP_ANA_DIR.
#
# EVNDISPSYS
#       ED executables are expected to be in $EVNDISPSYS/bin

MAX_PARALLEL_JOBS = 200

# HYBRID_VERSION: either "1" or "2"
HYBRID_VERSION = "2"

# Optics: Either ["DC"] or ["SC"]; Do not try ["DC", "SC"] yet. 
Optics  =                  ["SC"]

# NumRanges: run number to analyze.
# The set of numbers is generated by "myrange".
# set(): specifies run numbers to skip. Useful if simulation file doesn't exist or EventDisplay fails on it.

# Taking all simtel_array files into account (run 1026 is missing):
# NumRanges = {"gamma": [1, 301], "proton": [1, 2001, set([1026])]}

# ED is buggy at the time, but we need to keep going...:
#NumRanges = {"gamma": [1, 10, set([5,8,10])], "proton": [1, 20, set([5,6,8,11,12,13,14,17,19,1026])]}
#NumRanges = {"gamma": [1, 301, set()], "proton": [1, 2001, set([881,1018,1026,1029,1047,1147,1271,1373,1398,1399,1788,1822])]}
NumRanges = {"gamma": [1, 2, set()], "proton": [1, 2, set([881,1018,1026,1029,1047,1147,1271,1373,1398,1399,1788,1822])]}

#TMVA_Energy_Bins = ["Extended"]
TMVA_Energy_Bins = ["6bins"]

LOCAL_PARAMETERS_DIR = os.environ['u01'] + "/software/redhat5-x86_64-64bit-gcc41/eventdisplay/LOCAL"
SUBARRAY_LIST = LOCAL_PARAMETERS_DIR + "/SUBARRAYS/subarray_all-tels.lst"
ScratchDirRoot = "/scratch/EventDisplayScratch-" + getpass.getuser()
#SUBARRAY_LIST = LOCAL_PARAMETERS_DIR + "/SUBARRAYS/subarray_all-tels.lst



# ----- Most Important Cuts: ---------------

# Pixel "image cut"
def gen_img(dictionary):
    return ["10.0"]

# Pixel "boder cut"
def gen_brd(dictionary):
    return ["5.0"]

# Image SIZE cut:
def gen_size(dictionary):
    return ["30.0"]

# ------ End of Most Important Cuts --------

def gen_tubes(dictionary):
    return ["4"]
def gen_rec(dictionary):
    return ["4"]
def gen_loss(dictionary):
    return ["0.05"]
def gen_ang(dictionary):
    return ["10.0"]

# ED_PARAM_DIR = basename $OBS_EVNDISP_ANA_DIR
ED_PARAM_DIR = "EVNDISP-4.XX.CTA.runparameter"

OUTPUT_DATA_ROOT = os.environ['u01'] + "/EventDisplayAnalysis/TOBIAS"
#OUTPUT_DATA_ROOT = os.environ['u01'] + "/EventDisplayAnalysis/CFG0" + HYBRID_VERSION
INPUT_DATA_ROOT  = os.environ['u01'] + "/CTASims/MC/MST61_B120_S001/simtel"

# ==============================       END OF SCRIPT PARAMETERS      ==========================================

print "sys.argv: ", sys.argv
os.chdir(OUTPUT_DATA_ROOT)

EUp =       {"gamma":   4500, "proton":   5000} # Some part of MC file name which probably stands for Upper Energy.

def gen_particles(dictionary):
    return ["gamma", "proton"]
def gen_gamma_particle(dictionary):
    return ["gamma"]
def gen_optics(dictionary):
    return Optics
def gen_nums(dictionary):
    return list(myrange(*(NumRanges[dictionary["part"]])))

def gen_tmvaf(dictionary):
    return TMVA_Energy_Bins

def gen_tmvai(dictionary):
    with open(TmvaEnergyBinsFileFromPar(dictionary), 'r') as file:
        energy_bins_reader = csv.reader(file, delimiter=' ', skipinitialspace=True)
        return list(range(0, len(energy_bins_reader.next())))

def gen_updated_dict(dict1, update):
    result = dict(dict1)
    result.update(update)
    return result

def check_output_with_echo(command_list):
    print command_list
    sys.stdout.flush()
    print subprocess.check_output(command_list)
    sys.stdout.flush()

def check_output_with_echo_shell(command):
    print command
    sys.stdout.flush()
    print subprocess.check_output(command, shell = True)
    sys.stdout.flush()

def make_args(orig_list, dim_list, dim_funcs):
    result = list(orig_list)
    for dim in dim_list:
       result = dict_prod(result, dim, dim_funcs[dim])
    return result

def dict_prod(list1, key2, dim2_func):
    result = [gen_updated_dict(dict1, {key2: list2_item}) for dict1 in list1 for list2_item in dim2_func(dict1)]
    return result


def myrange(i1, i2, excluded):
    iter = i1 
    while True:
        if iter in excluded:
            iter = iter + 1
            continue
        if iter >= i2:
            return
        else:
            yield iter
        iter = iter + 1


def TableDepPars(TablePar):
    return dict_prod([TablePar], "num", gen_nums)

def MscwTableDepPar(MscwPar):
    return gen_updated_dict(MscwPar, {"part": "gamma"})

def UpdateParticle(dictionary, particle):
    return gen_updated_dict(dictionary, {"part": particle})

def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

def bvv_call_with_logfile(command_list, log_file_name):
    with open(log_file_name, "w") as std_file:
        subprocess.check_call(command_list, stdout=std_file, stderr=subprocess.STDOUT)

def SimtelRootFromNum(dictionary):
    if is_number(dictionary['num']):
        number_field = "{0[num]:06d}"
    else:
        number_field = "{0[num]}"

    return ("{0[part]}_E1000_{pEUp}_ZN200_AZ000_TH000_" + number_field).format(dictionary, pEUp=EUp[dictionary["part"]])
       

def SimtelFromNum(dictionary):
    return ("MST61{0[opt]}CFG0" + HYBRID_VERSION + "/" + SimtelRootFromNum(dictionary) + "_simtel.dat.gz").format(dictionary, pEUp=EUp[dictionary["part"]])

def VdstFromNum(dictionary):
    return SimtelRootFromNum(dictionary).format(dictionary, pEUp=EUp[dictionary["part"]]) + "_vdst.root"

def VdstLogFromNum(dictionary):
    return SimtelRootFromNum(dictionary).format(dictionary, pEUp=EUp[dictionary["part"]]) + "_vdst.log"

def EventdisplayParamFileRootFromPar(dictionary):
    return 'Tubes{tubes}_Rec{rec}_Loss{loss}_Ang{ang}_Img{img}_Brd{brd}_Size{size}'.format(**dictionary)

def TableFromNum(dictionary):
    return SimtelRootFromNum(gen_updated_dict(dictionary, {"num": "table"})) + "_" + EventdisplayParamFileRootFromPar(dictionary) + ".root"

def TableLogFromNum(dictionary):
    return SimtelRootFromNum(gen_updated_dict(dictionary, {"num": "table"})) + "_" + EventdisplayParamFileRootFromPar(dictionary) + ".log"


def MscwFromNum(dictionary):
    return SimtelRootFromNum(gen_updated_dict(dictionary, {"num": "mscw"})) + "_" + EventdisplayParamFileRootFromPar(dictionary) + ".root"

def MscwLogFromNum(dictionary):
    return SimtelRootFromNum(gen_updated_dict(dictionary, {"num": "mscw"})) + "_" + EventdisplayParamFileRootFromPar(dictionary) + ".log"

def EventdisplayParamFileFromPar(dictionary):
    return (ED_PARAM_DIR + '/ParameterFiles/EVNDISP.reconstruction.runparameter_' + EventdisplayParamFileRootFromPar(dictionary)).format(**dictionary)

def EventdisplayFromNum(dictionary):
    return SimtelRootFromNum(dictionary) + "_" + EventdisplayParamFileRootFromPar(dictionary) + "_ed.root"

def EventdisplayLogFromNum(dictionary):
    return SimtelRootFromNum(dictionary) + "_" + EventdisplayParamFileRootFromPar(dictionary) + "_ed.log"

def EventdisplayBunch(dictionary):
    return  SimtelRootFromNum(gen_updated_dict(dictionary, {"num": "*"})) + "_" + EventdisplayParamFileRootFromPar(dictionary) + "_ed.root"

def TmvaEnergyBinsFileFromPar(dictionary):
    #nodebug:
    #print "In TmvaEnergyBinsFileFromPar: ", dictionary
    return LOCAL_PARAMETERS_DIR + "/" + "TMVA-Energy-Bins_{tmvaf}.txt".format(**dictionary)

def TmvaParamFileFromPar(dictionary):
    return TmvaWithEnergyPrefixFromPar(dictionary).format(**dictionary) + ".runparameter"

def TmvaFromPar(dictionary):
    return TmvaWithEnergyPrefixFromPar(dictionary).format(**dictionary) + ".tar.bz2"

def TmvaWithEnergyPrefixFromPar(dictionary):
    return ("{opt}_" + EventdisplayParamFileRootFromPar(dictionary) + "_TMVA-{tmvaf}_{tmvai}").format(**dictionary)

def TmvaPrefixFromPar(dictionary):
    return ("{opt}_" + EventdisplayParamFileRootFromPar(dictionary) + "_TMVA-{tmvaf}").format(**dictionary)

def IrfGammaFromPar(dictionary):
    return ("{opt}_{part}_" + EventdisplayParamFileRootFromPar(dictionary) + "_irf.root").format(**dictionary)

def IrfGammaLogFromPar(dictionary):
    return ("{opt}_{part}_" + EventdisplayParamFileRootFromPar(dictionary) + "_irf.log").format(**dictionary)

def Invert(f, domain):
    def Inverted(x):
        for arg in domain:
            if f(arg) == x:
                return arg
    return Inverted

SimTelParDims =  ["part",                "opt",             "num"]
SimTelParFuncs = {"part": gen_particles, "opt": gen_optics, "num": gen_nums}

EventdisplayParDims =  ["tubes",            "rec",          "loss",           "ang",          "img",          "brd",          "size"]
EventdisplayParFuncs = {"tubes": gen_tubes, "rec": gen_rec, "loss": gen_loss, "ang": gen_ang, "img": gen_img, "brd": gen_brd, "size": gen_size}
TmvaParDims = ["tmvaf"]
TmvaParFuncs = {"tmvaf": gen_tmvaf}
TmvaParWithEnergyDims = TmvaParDims + ["tmvai"]
TmvaParWithEnergyFuncs = gen_updated_dict(TmvaParFuncs, {"tmvai": gen_tmvai})
TableParDims  = ["part", "opt"] + EventdisplayParDims

TableParFuncs = gen_updated_dict(gen_updated_dict(SimTelParFuncs, EventdisplayParFuncs), {"part": gen_gamma_particle})
MscwParFuncs = gen_updated_dict(TableParFuncs, {"part": gen_particles})
SimTelPars = make_args([{}], SimTelParDims, SimTelParFuncs)
EventdisplayParamFilePars = make_args([{}], EventdisplayParDims, EventdisplayParFuncs)
EventdisplayPars = make_args(SimTelPars, EventdisplayParDims, EventdisplayParFuncs)
TablePars = make_args([{}],  TableParDims,  TableParFuncs)
MscwPars  = make_args([{}],  TableParDims,  MscwParFuncs) # dimensions are like for TablePars
TmvaWithEnergyPars = make_args(TablePars, TmvaParWithEnergyDims, TmvaParWithEnergyFuncs)
IrfGammaPars = make_args(TablePars, TmvaParDims, TmvaParFuncs)

print IrfGammaPars



########################################################################
########################################################################
##################        BEGIN  RULE  DEFINITIONS        ##############
########################################################################
########################################################################
# {{{
def rule_consistency_check(target):
    print target + " checked:)"
bvvPyMakeNoArgs.queues[rule_consistency_check] = "express"

def rule_touch(target):
    subprocess.call("touch " + OUTPUT_DATA_ROOT + "/" + target, shell=True)
bvvPyMakeNoArgs.queues[rule_touch] = "express"

def rule_ed_param_dir(target):
    check_output_with_echo(["cp", "-R", os.environ['OBS_EVNDISP_ANA_DIR'], OUTPUT_DATA_ROOT])
bvvPyMakeNoArgs.queues[rule_ed_param_dir] = "express"

def rule_eventdisplay_param_file(target):
#{{{
    EventdisplayPar = Invert(EventdisplayParamFileFromPar, EventdisplayPars)(target)
#{{{
    RecParTemplate = \
'''
eventdisplay reconstruction parameter file
===========================================

i) trace integration and image cleaning parameter
--------------------------------------------------

 trace integration <integration method (0=off/1=default/2=sliding window)>
* -1 FADCANALYSIS 1
 double pass method <doublepass (on=1, off=0)> <integration window length for pass 1> <integration method for pass 1 (0/1)>
* -1 FADCDOUBLEPASS 1 12 0
 trace integration window <window 1> <window 2>
* -1 FADCSUMMATIONWINDOW 6 18
 trace integration start (for window 1) <sample> [optional: shift of window start for double pass]
* -1 FADCSUMMATIONSTART 2 -1

 image cleaning <method=TWOLEVELCLEANING/TIMECLUSTERCLEANING> <FIXED/VARIABLE>
* -1 IMAGECLEANINGMETHOD TWOLEVELCLEANING FIXED
 image cleaning thresholds <image> <border>
(image cleaning levels 10/5 * sqrt(NSB/0.1GHz) )

* -1 IMAGECLEANINGTHRESHOLDS {img} {brd}

 image calculation at the edge of the camera
* -1 LLEDGEFIT 0. 0

ii) quality cuts applied before the array analysis 
--------------------------------------------------

   DEFAULTS:
   minimum number of images required for stereo reconstruction
    -1 MNIMAGE 2
   minimum angle between image axes for two telescope analysis [deg]
    -1 MINANGLE 5.
   minimum number of channels for all telescopes
    -1 MINTUBES 4
   maximum number of low gain channels per telescope
    -1 MAXLOWGAIN 5000
   minimum local distance for all telescopes [deg]
    -1 MINDIST -1.e3
   maximum local distance for all telescopes [deg]
    -1 MAXDIST  1.e3
   minimum alpha for all telescopes [deg]
    -1 MINALPHA -1.e3
   maximum alpha for all telescopes [deg]
    -1 MAXALPHA 1.e3
   minimum image size for all telescopes [dc]
    -1 MINSIZE 400
   ignore all pointing corrections (default: off)
    -1 USEEVNPOINTING 0
   maximum loss of image size on edge of the camera [%]
    -1 MAXLOSS 0.05
   maximum width/length (to remove images to close to the telescopes)
    -1 MAXWIDTHLENGTH 1.e10

---------------------------------------------------------------------------------------------------
Quality cut set 0:

* -1 RECMETHOD {rec}
* -1 MINSIZE {size}
* -1 MINANGLE {ang}
* -1 MINTUBES {tubes}
* -1 MAXLOSS {loss}
    '''
#}}}
    with open(target, "w") as f:
       f.write(RecParTemplate.format(**EventdisplayPar))
#}}}
bvvPyMakeNoArgs.queues[rule_eventdisplay_param_file] = "express"

def rule_ed(target):
#{{{
    EventdisplayPar = Invert(EventdisplayFromNum, EventdisplayPars)(target)
    subprocess.check_call(["mkdir", "-p", ScratchDirRoot])
    TMPDIR = tempfile.mkdtemp(dir = ScratchDirRoot)
    console_textwidth = 239
    ed_param_file = OUTPUT_DATA_ROOT + "/" + EventdisplayParamFileFromPar(EventdisplayPar)
    vdst_file_local = TMPDIR + "/" + os.path.basename(VdstFromNum(EventdisplayPar))
    vdst_file_dest = OUTPUT_DATA_ROOT + "/" + VdstFromNum(EventdisplayPar)
    vdst_logfile_local = TMPDIR + "/" + os.path.basename(VdstLogFromNum(EventdisplayPar))
    vdst_logfile_dest = OUTPUT_DATA_ROOT + "/" + VdstLogFromNum(EventdisplayPar)

    ed_file_local = TMPDIR + "/" + os.path.basename(EventdisplayFromNum(EventdisplayPar))
    ed_file_dest = OUTPUT_DATA_ROOT + "/" + EventdisplayFromNum(EventdisplayPar)
    ed_logfile_local = TMPDIR + "/" + os.path.basename(EventdisplayLogFromNum(EventdisplayPar))
    ed_logfile_dest = OUTPUT_DATA_ROOT + "/" + EventdisplayLogFromNum(EventdisplayPar)

    simtel_file_repo = INPUT_DATA_ROOT + "/" + SimtelFromNum(EventdisplayPar)
    simtel_file_local = TMPDIR + "/" + os.path.basename(SimtelFromNum(EventdisplayPar))

    #subarray_list = os.environ['u01'] + "/software/redhat5-x86_64-64bit-gcc41/eventdisplay/LOCAL/SUBARRAYS/subarray_all-tels.lst"
    subarray_list = SUBARRAY_LIST

    VdstFromHessioProg = os.environ['EVNDISPSYS'] + "/bin/CTA.convert_hessio_to_VDST"
    EdProg = os.environ['EVNDISPSYS'] + "/bin/evndisp"
    VdstConvCommand = [VdstFromHessioProg, "-f", "1", "-a", subarray_list, "-o", vdst_file_local, simtel_file_local]
    os.environ['OBS_EVNDISP_ANA_DIR'] = OUTPUT_DATA_ROOT + "/" + ED_PARAM_DIR
    EdCommand = [EdProg, "-sourcefile", vdst_file_local, "-writenoMCTree", "-reconstructionparameter", ed_param_file, "-shorttree", "-l2setspecialchannels", "nofile", "-output", ed_file_local]

    try:
        # Start doing something, finally:
        #queue_info_command = ["queue", "u36", "-info"]
        #print queue_info_command
        #sys.stdout.flush()
        #print subprocess.check_output(queue_info_command)
        #sys.stdout.flush()

        #cp_command = ["queue", "u36", "cp", "-v", simtel_file_repo, TMPDIR]
        cp_command = ["cp", "-v", simtel_file_repo, TMPDIR]
        print cp_command
        sys.stdout.flush()
        print subprocess.check_output(cp_command)
        sys.stdout.flush()
        print subprocess.check_output(["ls", "-lh", TMPDIR])
        sys.stdout.flush()

        print textwrap.fill(str(VdstConvCommand), console_textwidth)
        sys.stdout.flush()
        bvv_call_with_logfile(VdstConvCommand, vdst_logfile_local)
        sys.stdout.flush()
        print textwrap.fill(str(EdCommand), console_textwidth)

        bvv_call_with_logfile(EdCommand, ed_logfile_local)
        sys.stdout.flush()
    finally:
        #subprocess.call(["mv", vdst_file_local, vdst_file_dest])
        subprocess.call(["mv", vdst_logfile_local, vdst_logfile_dest])
        subprocess.call(["mv", ed_logfile_local, ed_logfile_dest])
        #subprocess.call(["queue", "u36", "mv", ed_file_local, ed_file_dest])
        subprocess.call(["mv", ed_file_local, ed_file_dest])
        subprocess.call(["ls", "-lh", TMPDIR])
        subprocess.call(["rm", "-rf", TMPDIR])
        #sys.exit(123)
#}}}
#bvvPyMakeNoArgs.queues[rule_ed] = "long" # good enough for gammas, with a wide margin.
bvvPyMakeNoArgs.queues[rule_ed] = "xxl"

def table_dependency_template(TablePar):
#{{{
    TableDepParsList = TableDepPars(TablePar)
    table_file = TableFromNum(TablePar)
    bvvPyMakeNoArgs.depend[table_file] = map(EventdisplayFromNum, TableDepParsList)
#}}}
map(table_dependency_template, TablePars)

def rule_table(target):
#{{{
    TablePar = Invert(TableFromNum, TablePars)(target)
    print "TablePar:", TablePar
    sys.stdout.flush()
    subprocess.check_call(["mkdir", "-p", ScratchDirRoot])
    TMPDIR = tempfile.mkdtemp(dir = ScratchDirRoot)

    console_textwidth = 239

    table_file_local = TMPDIR + "/" + os.path.basename(TableFromNum(TablePar))
    table_file_dest = OUTPUT_DATA_ROOT + "/" + TableFromNum(TablePar)
    table_logfile_local = TMPDIR + "/" + os.path.basename(TableLogFromNum(TablePar))
    table_logfile_dest = OUTPUT_DATA_ROOT + "/" + TableLogFromNum(TablePar)

    ed_files_local = TMPDIR + "/" + EventdisplayBunch(TablePar)

    TableProg = os.environ['EVNDISPSYS'] + "/bin/mscw_energy"
    TableCommand = [TableProg, "-pe", "-filltables=1", "-ze=20", "-noise=250", "-woff=0.0", "-maxCoreError=250", "-minImages=2", "-arrayrecid=0", "-tablefile", table_file_local, "-inputfile", ed_files_local]

    try:
        subprocess.call(["sync"])
        for ed_file in bvvPyMakeNoArgs.depend[target]:
            CopyCommand = ["cp", OUTPUT_DATA_ROOT + "/" + ed_file, TMPDIR]
            check_output_with_echo(CopyCommand)
        print textwrap.fill(str(TableCommand), console_textwidth)
        sys.stdout.flush()
        bvv_call_with_logfile(TableCommand, table_logfile_local)
        sys.stdout.flush()
    finally:
        subprocess.call(["ls", "-lh", TMPDIR])
        subprocess.call(["mv", table_file_local, table_file_dest])
        subprocess.call(["mv", table_logfile_local, table_logfile_dest])
        subprocess.call(["ls", "-lh", TMPDIR])
        subprocess.call(["rm", "-rf", TMPDIR])
        subprocess.call(["sync"])
        #sys.exit(123)
#bvvPyMakeNoArgs.queues[rule_ed] = "long" # good enough for gammas, with a wide margin.
#}}}
bvvPyMakeNoArgs.queues[rule_table] = "short"

def table_rule_template(TablePar):
#{{{
    table_file = TableFromNum(TablePar)
    bvvPyMakeNoArgs.rules[table_file] = rule_table
#}}}
map(table_rule_template, TablePars)

def mscw_dependency_template(MscwPar):
#{{{
    mscw_file = MscwFromNum(MscwPar)
    TablePar = MscwTableDepPar(MscwPar)
    table_file = TableFromNum(TablePar)
    MscwDepEDParsList = TableDepPars(MscwPar)

    bvvPyMakeNoArgs.depend[mscw_file] = [table_file] + map(EventdisplayFromNum, MscwDepEDParsList)
#}}}
map(mscw_dependency_template, MscwPars)

def rule_mscw(target):
#{{{
    MscwPar = Invert(MscwFromNum, MscwPars)(target)
    print "MscwPar:", MscwPar
    sys.stdout.flush()

    subprocess.check_call(["mkdir", "-p", ScratchDirRoot])
    TMPDIR = tempfile.mkdtemp(dir = ScratchDirRoot)
    console_textwidth = 239

    mscw_file_local = TMPDIR + "/" + os.path.basename(target)
    mscw_file_dest = OUTPUT_DATA_ROOT + "/" + target
    mscw_logfile_local = TMPDIR + "/" + os.path.basename(MscwLogFromNum(MscwPar))
    mscw_logfile_dest = OUTPUT_DATA_ROOT + "/" + MscwLogFromNum(MscwPar)

    ed_files_local = TMPDIR + "/" + EventdisplayBunch(MscwPar)
    MscwGammaPar = MscwTableDepPar(MscwPar)
    table_file_local = TMPDIR + "/" + os.path.basename(TableFromNum(MscwGammaPar))

    MscwProg = os.environ['EVNDISPSYS'] + "/bin/mscw_energy"
    MscwCommand = [MscwProg, "-pe", "-arrayrecid=0", "-noNoTrigger", "-writeReconstructedEventsOnly", "-shorttree", "-tablefile", table_file_local, "-inputfile", ed_files_local, "-outputfile", mscw_file_local]

    try:
        subprocess.call(["sync"])
        for ed_file_or_table in bvvPyMakeNoArgs.depend[target]:
            CopyCommand = ["cp", OUTPUT_DATA_ROOT + "/" + ed_file_or_table, TMPDIR]
            check_output_with_echo(CopyCommand)
        print textwrap.fill(str(MscwCommand), console_textwidth)
        sys.stdout.flush()
        bvv_call_with_logfile(MscwCommand, mscw_logfile_local)
        sys.stdout.flush()
    finally:
        subprocess.call(["ls", "-lh", TMPDIR])
        sys.stdout.flush()
        subprocess.call(["mv", mscw_file_local, mscw_file_dest])
        subprocess.call(["mv", mscw_logfile_local, mscw_logfile_dest])
        subprocess.call(["ls", "-lh", TMPDIR])
        subprocess.call(["rm", "-rf", TMPDIR])
        subprocess.call(["sync"])
#}}}
bvvPyMakeNoArgs.queues[rule_mscw] = "xxl"
    
def mscw_rule_template(MscwPar):
#{{{
    mscw_file = MscwFromNum(MscwPar)
    bvvPyMakeNoArgs.rules[mscw_file] = rule_mscw
#}}}
map(mscw_rule_template, MscwPars)


def rule_tmva_param_file(target):
#{{{
    TMVAPar = Invert(TmvaParamFileFromPar, TmvaWithEnergyPars)(target)
#{{{
    TMVAParamFileTemplate = \
    '''
Runparameter for TMVA Training
=====================================

-- only lines with a '*' in the first column are read in --

##############################################
optimization method (MC or GA)
(SplitSeed=0)

 MVA_METHOD BDT
* MVA_METHOD BDT NTrees=400:MaxDepth=3
 MVA_METHOD BOXCUTS FitMethod=GA:PopSize=3000

##############################################
training variables
(name must correspond to variable names in data tree of mscw root files)

VARIABLE <variable name> <type (float=F, integer=I)>  <cut range min> <cut range max> <cut category>

cut categories:  NotEnforced, FMax, FMin, FSmart

* VARIABLE F -2.0  1.0 NotEnforced MSCW
* VARIABLE F -2.0  1.0 NotEnforced MSCL
!!!  VARIABLE F -1 -1 NotEnforced log10(ENERGYCHI2VARIABLE)
* VARIABLE F -1 -1 NotEnforced log10(EChi2)
* VARIABLE F 0.0 100. FMax EmissionHeight
* VARIABLE F -1 -1 NotEnforced log10(EmissionHeightChi2)
* VARIABLE F -1 -1 NotEnforced log10(SizeSecondMax)
* VARIABLE I 2 -1 NotEnforced NImages_Ttype

##############################################
spectator variables
* SPECTATOR runNumber
* SPECTATOR eventNumber
* SPECTATOR MCze
* SPECTATOR MCaz
* SPECTATOR MCxoff
* SPECTATOR MCyoff
* SPECTATOR MCxcore
* SPECTATOR MCycore
* SPECTATOR MCe0
* SPECTATOR NImages
* SPECTATOR Xoff
* SPECTATOR Yoff
* SPECTATOR Xcore
* SPECTATOR Ycore
!!!  SPECTATOR ENERGYVARIABLE
* SPECTATOR Erec


##############################################
Minimum number of signal and background events needed 
MINEVENTS <signal events> <background events>
(this crosschecks the event numbers before the training; default is 50)

* MINEVENTS 50 50

##############################################
Selection cut before training
(similar to TTree::Draw() selection cuts)

!!! SELECTION_CUTS MSCW>-2.&&MSCW<2.&&MSCL>-2.&&MSCL<5.&&ENERGYCHI2VARIABLE>=0.&&log10(ENERGYCHI2VARIABLE)<-0.4&&ENERGYVARIABLE>0.&&EmissionHeight>0.&&NImages>=MINIMAGES
* SELECTION_CUTS MSCW>-2.&&MSCW<2.&&MSCL>-2.&&MSCL<5.&&EChi2>=0.&&log10(EChi2)<-0.4&&Erec>0.&&EmissionHeight>0.&&NImages>=2

##############################################
Prepare training options
(e.g. number of signal and background events used for training: nTrain_Signal=100:nTrain_Background=100)

 PREPARE_TRAINING_OPTIONS SplitMode=Random:!V
* PREPARE_TRAINING_OPTIONS SplitMode=Block:!V:SplitSeed=0

signal weight 
* SIGNALWEIGHT 1.
background weights 
* BACKGROUNDWEIGHT 1.

##############################################
input files (added by script)
(list of file)

* ENERGYBINS 0 {EMIN} {EMAX}
* OUTPUTFILE {OUTPUTDIR} {PREFIX}
* SIGNALFILE {GAMMA_MSCW_FILE}
* BACKGROUNDFILE {PROTON_MSCW_FILE}
'''
#}}}
    with open(TmvaEnergyBinsFileFromPar(TMVAPar), 'r') as file:
        energy_bins_reader = csv.reader(file, delimiter=' ', skipinitialspace=True)
        EminList = energy_bins_reader.next()
        EmaxList = energy_bins_reader.next()
    with open(target, "w") as f:
        Ind = TMVAPar["tmvai"]
        f.write(TMVAParamFileTemplate.format(EMIN = EminList[Ind], EMAX = EmaxList[Ind], PREFIX = TmvaWithEnergyPrefixFromPar(TMVAPar), OUTPUTDIR = "./", GAMMA_MSCW_FILE = MscwFromNum(TMVAPar), PROTON_MSCW_FILE = MscwFromNum(UpdateParticle(TMVAPar, "proton"))))
#}}}
bvvPyMakeNoArgs.queues[rule_tmva_param_file] = "express"


def tmva_dependency_template(TMVAParam):
#{{{
    target = TmvaFromPar(TMVAParam)
    tmva_param_file = TmvaParamFileFromPar(TMVAParam)
    gamma_mscw = MscwFromNum(TMVAParam)
    proton_mscw = MscwFromNum(UpdateParticle(TMVAParam, "proton"))
    bvvPyMakeNoArgs.depend[target] = [tmva_param_file, gamma_mscw, proton_mscw]
#}}}
map(tmva_dependency_template, TmvaWithEnergyPars)

def rule_tmva(target):
#{{{
    TMVAPar = Invert(TmvaFromPar, TmvaWithEnergyPars)(target)

    tmva_param_file_local = os.path.basename(TmvaParamFileFromPar(TMVAPar))
    tmva_file_local = os.path.basename(TmvaFromPar(TMVAPar))
    tmva_logfile_local = TmvaWithEnergyPrefixFromPar(TMVAPar) + ".log"

    TMVAProg = os.environ['EVNDISPSYS'] + "/bin/trainTMVAforGammaHadronSeparation"
    TMVACommand = [TMVAProg, tmva_param_file_local]

    try:
        subprocess.check_call(["mkdir", "-p", "/scratch/EventDisplayScratch"])
        TMPDIR = tempfile.mkdtemp(dir = "/scratch/EventDisplayScratch")
        subprocess.call(["sync"])
        os.chdir(TMPDIR)

        for Prereq in bvvPyMakeNoArgs.depend[target]:
            check_output_with_echo(["cp", OUTPUT_DATA_ROOT + "/" + Prereq, TMPDIR])

        subprocess.call(["sync"])

        check_output_with_echo(["pwd"])
        check_output_with_echo(["ls", "-lh", TMPDIR])

        bvv_call_with_logfile(TMVACommand, tmva_logfile_local)
        check_output_with_echo(["ls", "-lh"])

        TarCommand = "tar -jcvf " + target + " " + TmvaWithEnergyPrefixFromPar(TMVAPar) + ".root " + TmvaWithEnergyPrefixFromPar(TMVAPar) + "*.class.C " + TmvaWithEnergyPrefixFromPar(TMVAPar) + "*.weights.xml"
        check_output_with_echo_shell(TarCommand)
    finally:
        subprocess.call(["ls", "-lh"])
        subprocess.call(["mv", target, OUTPUT_DATA_ROOT])
        subprocess.call(["mv", tmva_logfile_local, OUTPUT_DATA_ROOT])
        subprocess.call(["ls", "-lh", TMPDIR])
        subprocess.call(["rm", "-rf", TMPDIR])
        subprocess.call(["sync"])
#}}}
bvvPyMakeNoArgs.queues[rule_tmva] = "long"

def tmva_rule_template(TMVAParam):
#{{{
    target = TmvaFromPar(TMVAParam)
    bvvPyMakeNoArgs.rules[target] = rule_tmva
#}}}
map(tmva_rule_template, TmvaWithEnergyPars)

def irf_gamma_dependency_template(Par):
    target = IrfGammaFromPar(Par)
    TMVAEnergyBinsPars = make_args([Par], ["tmvai"], {"tmvai": gen_tmvai})
    #nodebug:
    #print "In irf_gamma_dependency_template: ", "-->" + target + "<--", Par, TMVAEnergyBinsPars
    TMVAOptimizationResults = map(TmvaFromPar, TMVAEnergyBinsPars)
    bvvPyMakeNoArgs.depend[target] = [MscwFromNum(Par), TmvaEnergyBinsFileFromPar(Par)] + TMVAOptimizationResults
map(irf_gamma_dependency_template, IrfGammaPars)

def rule_irf_gamma(target):
    Par = Invert(IrfGammaFromPar, IrfGammaPars)(target)
#{{{
    CutFileContents = \
    '''
 Gamma/hadron cut file for CTA using a TMVA separator
 ====================================================

 File to be used with the corresponding scripts in $EVNDISPSYS/scripts/CTA/:
 CTA.EFFAREA.sub_analyse.sh and CTA.EFFAREA.subAllParticle_analyse.sh

 fixed signal efficiency

 To be used for gamma simulations

========================================================
!!! cutselection 40 DIRECTIONCUT
* cutselection 40 2
========================================================
Stereo cuts:
--------------------------------------------------------
i) stereo quality cuts
successfull core and direction reconstruction (>=0.)
* arraychi2 0. 1.e99
distance of core position to telescopes [m]
* arraycore -1. 1.e99
(default value is 250)
* telcoredistance 250.
size of the camera [deg], all events with direction
outside that intervall are ignored
* cameraedge -1. 1.e99

==========================================================
replaced by parent script
!!!  mc_xy_off OFFMIN OFFMAX
* mc_xy_off 0.0 1e+9
==========================================================

!!! arrayntel MINIMAGES 10000
* arrayntel 2 10000

ii) direction cut [deg2]
* angres 80

iii) gamma hadron cuts:
b) mean scaled width cut (use cut selector 0 in runlist)
* arraymscw -2. 2.
* arraymscl -2. 5.

iv) energy reconstruction cuts
echi2 is a measure of the difference between the energies
estimated per individual telescope
* arrayechi2 0. 0.40
cut on energy of reconstruction shower (on linear energy scale, in [TeV])
* arrayerec 0. 1.e99

emission height
* arrayemission 0. 1.e99


v)  TMVA cuts
TMVACUTS <MVA Method> <file index min> <file index max> <weight file (without energy bin index and suffix)>
(DEFAULT 0 12)
!!! TMVAPARAMETER BDT 0 7 $CTA_USER_DATA_DIR/analysis/AnalysisData/DATASET/SUBARRAY/TMVA/TMVACUTDIR-WOBBLEOFFSET/ BDT_
* TMVAPARAMETER BDT 0 {MaxTMVAEnergyBin:d} ./ {TMVAPrefix}_
TMVACUTS <signal efficiency> <probability threshold> <Optimize (for source with this CU strength)> <file with particle numbers before cuts>
TMVACUTS 0.4 -99.
* TMVASignalEfficiency 9999 0.40
'''
    RunListContents = \
    '''
FILLINGMODE:
     0: fill and use angular resolution for energy dependent theta2 cuts.
     2: angular resolution only,
* FILLINGMODE 0
* ENERGYRECONSTRUCTIONMETHOD 0
* ENERGYAXISBINS 60
* ENERGYRECONSTRUCTIONQUALITY 0
* AZIMUTHBINS 0
* ISOTROPICARRIVALDIRECTIONS 0
* TELESCOPETYPECUTS 1
* FILLMONTECARLOHISTOS 0
* ENERGYSPECTRUMINDEX  1 2.5 0.1
* IGNOREFRACTIONOFEVENTS 0.5
* CUTFILE {CutFile}
* SIMULATIONFILE_DATA {MscwFile}
'''
#}}}
    Prog = os.environ['EVNDISPSYS'] + "/bin/makeEffectiveArea"
    logfile_local = IrfGammaLogFromPar(Par) 
    CutFileVal = TmvaPrefixFromPar(Par) + "_irf.cutfile"
    RunListFileVal = TmvaPrefixFromPar(Par) + "_irf.runlist"
    MscwFileVal = MscwFromNum(Par)
    EffAreaCmd = [Prog, RunListFileVal, target]

    subprocess.check_call(["mkdir", "-p", ScratchDirRoot])
    TMPDIR = tempfile.mkdtemp(dir = ScratchDirRoot)
    subprocess.call(["sync"])

    try:
        os.chdir(TMPDIR)
        with open(CutFileVal, "w") as f:
            f.write(CutFileContents.format(TMVAPrefix = TmvaPrefixFromPar(Par), MaxTMVAEnergyBin = len(gen_tmvai(Par)) - 1))
        with open(RunListFileVal, "w") as f:
            f.write(RunListContents.format(CutFile = CutFileVal, MscwFile = MscwFileVal))
        TMVAEnergyBinsPars = make_args([Par], ["tmvai"], {"tmvai": gen_tmvai})
        TMVAOptimizationResults = map(TmvaFromPar, TMVAEnergyBinsPars)

        for Prereq in TMVAOptimizationResults:
            check_output_with_echo(["cp", OUTPUT_DATA_ROOT + "/" + Prereq, TMPDIR])
            check_output_with_echo(["tar", "-jxvf", Prereq])

        check_output_with_echo(["cp", OUTPUT_DATA_ROOT + "/" + MscwFileVal, TMPDIR])

        subprocess.call(["sync"])
        check_output_with_echo(["pwd"])
        check_output_with_echo(["ls", "-lh", TMPDIR])

        bvv_call_with_logfile(EffAreaCmd, logfile_local)
    finally:
        subprocess.call(["ls", "-lh"])
        subprocess.call(["mv", target, OUTPUT_DATA_ROOT])
        subprocess.call(["mv", logfile_local, OUTPUT_DATA_ROOT])
        subprocess.call(["mv", CutFileVal, OUTPUT_DATA_ROOT])
        subprocess.call(["mv", RunListFileVal, OUTPUT_DATA_ROOT])
        subprocess.call(["ls", "-lh", TMPDIR])
        subprocess.call(["rm", "-rf", TMPDIR])
        subprocess.call(["sync"])

bvvPyMakeNoArgs.queues[rule_irf_gamma] = "long"
#rule_irf_gamma(IrfGammaFromPar(IrfGammaPars[0]))
#exit(0)

def irf_gamma_rule_template(Par):
    target = IrfGammaFromPar(Par)
    bvvPyMakeNoArgs.rules[target] = rule_irf_gamma
map(irf_gamma_rule_template, IrfGammaPars)

# At this point, all required definitions are known.
bvvPyMakeNoArgs.dorule(OUTPUT_DATA_ROOT, globals())
# }}}^^^^^^^^^^^^^^^^  END OF RULE DEFINITIONS  ^^^^^^^^^^^^^^^^^^^^^^^^

########################################################################
########################################################################
##################           BEGIN DEPENDENCIES         ################
########################################################################
########################################################################
# {{{
all_ed_files = map(EventdisplayFromNum, EventdisplayPars)
all_table_files = map(TableFromNum, TablePars)
all_ed_param_files = map(EventdisplayParamFileFromPar, EventdisplayParamFilePars)
all_mscw_files = map(MscwFromNum, MscwPars)
all_tmva_param_files = map(TmvaParamFileFromPar, TmvaWithEnergyPars) 
all_tmva = map(TmvaFromPar, TmvaWithEnergyPars)
all_irf_gamma = map(IrfGammaFromPar, IrfGammaPars)

def num_dependency_template(EventdisplayPar):
    ed_file = EventdisplayFromNum(EventdisplayPar)
    bvvPyMakeNoArgs.depend[ed_file] = [INPUT_DATA_ROOT + "/" + SimtelFromNum(EventdisplayPar), EventdisplayParamFileFromPar(EventdisplayPar)]
    bvvPyMakeNoArgs.rules[ed_file] = rule_ed
map(num_dependency_template, EventdisplayPars)

def eventdisplay_param_file_template(EventdisplayParamFilePar):
    param_file = EventdisplayParamFileFromPar(EventdisplayParamFilePar)
    bvvPyMakeNoArgs.depend[param_file] = [ED_PARAM_DIR]
    bvvPyMakeNoArgs.rules[param_file] = rule_eventdisplay_param_file
map(eventdisplay_param_file_template, EventdisplayParamFilePars)


def tmva_param_file_rule_template(TMVAParam):
#{{{
    tmva_param_file = TmvaParamFileFromPar(TMVAParam)
    bvvPyMakeNoArgs.depend[tmva_param_file] = [TmvaEnergyBinsFileFromPar(TMVAParam)]
    
    bvvPyMakeNoArgs.rules[tmva_param_file] = rule_tmva_param_file
#}}}
map(tmva_param_file_rule_template, TmvaWithEnergyPars)


for k, v in bvvPyMakeNoArgs.depend.iteritems():
    print k, v
print bvvPyMakeNoArgs.rules

bvvPyMakeNoArgs.depend[ED_PARAM_DIR] = [os.environ['OBS_EVNDISP_ANA_DIR']]

bvvPyMakeNoArgs.depend['all_ed_files'] = all_ed_files
bvvPyMakeNoArgs.depend['all_ed_param_files'] = all_ed_param_files
bvvPyMakeNoArgs.depend['all_table_files'] = all_table_files
bvvPyMakeNoArgs.depend['all_mscw_files'] = all_mscw_files
bvvPyMakeNoArgs.depend['all_tmva_param_files'] = all_tmva_param_files
bvvPyMakeNoArgs.depend['all_tmva'] = all_tmva
bvvPyMakeNoArgs.depend['all_irf_gamma'] = all_irf_gamma
bvvPyMakeNoArgs.depend['test_target'] = ['test_prereq']

# }}} ^^^^^^^^^^^^^^^^^^^^^^ END OF DEPENDENCIES  ^^^^^^^^^^^^^^^^^^^^^^

########################################################################
########################################################################
##################        BEGIN  RULE  ASSIGNMENTS        ##############
########################################################################
########################################################################
# {{{
bvvPyMakeNoArgs.rules[ED_PARAM_DIR] = rule_ed_param_dir
bvvPyMakeNoArgs.rules['all_ed_files'] = rule_touch
bvvPyMakeNoArgs.rules['all_ed_param_files'] = rule_touch
bvvPyMakeNoArgs.rules['all_table_files'] = rule_touch
bvvPyMakeNoArgs.rules['all_mscw_files'] = rule_touch
bvvPyMakeNoArgs.rules['all_tmva_param_files'] = rule_touch
bvvPyMakeNoArgs.rules['all_tmva'] = rule_touch
bvvPyMakeNoArgs.rules['all_irf_gamma'] = rule_touch
bvvPyMakeNoArgs.rules['test_target'] = rule_touch
# }}} ^^^^^^^^^^^^^^^  END OF RULE ASSIGNMENTS  ^^^^^^^^^^^^^^^^^^^^^^^^

#bvvPyMakeNoArgs.make('all_irf_gamma', MAX_PARALLEL_JOBS, OUTPUT_DATA_ROOT)
#bvvPyMakeNoArgs.make('all_tmva', MAX_PARALLEL_JOBS, OUTPUT_DATA_ROOT)
#bvvPyMakeNoArgs.make('all_tmva_param_files', MAX_PARALLEL_JOBS, OUTPUT_DATA_ROOT)
bvvPyMakeNoArgs.make('all_mscw_files', MAX_PARALLEL_JOBS, OUTPUT_DATA_ROOT)
#bvvPyMakeNoArgs.make('all_table_files', MAX_PARALLEL_JOBS, OUTPUT_DATA_ROOT)
#bvvPyMakeNoArgs.make(ED_PARAM_DIR, MAX_PARALLEL_JOBS, OUTPUT_DATA_ROOT)
#bvvPyMakeNoArgs.make('all_ed_param_files', MAX_PARALLEL_JOBS, OUTPUT_DATA_ROOT)
